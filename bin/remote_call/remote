#!/usr/bin/env python3
  
# -*- coding: utf-8 -*-

# -*- mode: python -*-

# Author: noseglasses (shinynoseglasses@gmail.com)

import os
import logging
import string
import subprocess
import sys

indent_level = "   "

program_description = "Kaleidoscope remote call utility\n" \
                    + "   2019 by Florian Fleissner (shinynoseglasses@gmail.com)"

def is_exe(fpath):
   return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

class Command(object):
   
   def __init__(self):
      pass

class Command_Call(Command):
   
   def getName(self):
      return "call"
   
   def getArgsDescription(self):
      return "<function name> [arg_name=value...]"
   
   def run(self, args):
      if len(args) < 1:
         raise RuntimeError('Subcommand \'call\' requires a function name')
      else:
         func_name = args[0]
         
         print("Calling Kaleidoscope function " + func_name)
         #print("Args: " + str(args[1:]))
         
         self.communicator.callFunction(func_name, args[1:])
         
class Command_SetInput(Command):
            
   def getName(self):
      return "set_input"
   
   def getArgsDescription(self):
      return "<name> <value>"
   
   def run(self, args):
      if len(args) < 2:
         raise RuntimeError('Subcommand \'set_input\' requires an input name as second argument')
      else:
         input_name = args[0]
         print("Setting input " + input_name)
         
         if len(args) < 2:
            raise RuntimeError('Subcommand \'set_input\' requires a value as third argument')
         
         self.communicator.setInput(input_name, args[1])
         
class Command_GetInput(Command):
            
   def getName(self):
      return "get_input"
   
   def getArgsDescription(self):
      return "<name>"
   
   def run(self, args):
      if len(args) < 1:
         raise RuntimeError('Subcommand \'get_input\' requires an input name as second argument')
      else:
         input_name = args[0]
         self.communicator.getInput(input_name)
            
class Command_List(Command):
      
   def getName(self):
      return "list"
   
   def getArgsDescription(self):
      return ""

   def run(self, args):
      self.communicator.listPackages(sys.stdout)
      
class Command_Help(Command):
      
   def getName(self):
      return "help"
   
   def getArgsDescription(self):
      return ""
   
   def run(self, args):
      sys.stdout.write("commands available:\n")
      for (name, command) in self.communicator.commands.items():
         sys.stdout.write("   " + name + " " + command.getArgsDescription() + "\n")

class Communicator(object):
   
   def __init__(self):
      
      self.setupCommands()
      self.parseCommandLineArgs()
      self.findExecutables()
      self.readYamlFile()
      
      self.processCommand()
      
   def addCommand(self, cmd):
      cmd.communicator = self
      self.commands[cmd.getName()] = cmd
      
   def setupCommands(self):
      
      self.commands = {}
      
      self.addCommand(Command_Call())
      self.addCommand(Command_SetInput())
      self.addCommand(Command_GetInput())
      self.addCommand(Command_List())
      self.addCommand(Command_Help())
      
   def parseCommandLineArgs(self):
      
      import argparse

      parser = argparse.ArgumentParser(description='Remote communication with Kaleidoscope driven devices.')
            
      parser.add_argument('--kaleidoscope_repo_dir', \
                           help = 'The path to the Kaleidoscope repository directory')
      parser.add_argument('--interface_description_yaml', \
                           help = 'The filename of a yaml input file containing the remote call interface description',
                           default = '')
      
      parser.add_argument(dest="remaining_args", nargs=argparse.REMAINDER, help="See command descriptions below")
      
      # TODO: Explain all commands
      # TODO: Turn commands into functors that are stored in a list
      
      args = parser.parse_args()
      
      self.kaleidoscope_repo_dir = args.kaleidoscope_repo_dir
      self.interface_description_yaml = args.interface_description_yaml
      self.remaining_args = args.remaining_args
      
   def findExecutables(self):
      
      self.focus_test_executable = self.kaleidoscope_repo_dir + '/bin/focus-test'
      
      if not is_exe(self.focus_test_executable):
         raise RuntimeError('Unable to find focus-test executable \'' + self.focus_test_executable + '\'')
   
   def readYamlFile(self):
      import yaml

      with open(self.interface_description_yaml) as f:
    
         self.package_tree = yaml.safe_load(f)
         #print(data)
         
   def getPackages(self):
         
      if not "packages" in self.package_tree.keys():
         raise RuntimeError('No packages defined in yaml file')
         
      return self.package_tree["packages"]
   
   def getPackage(self, package_path_tokens):
         
      packages = self.getPackages()
      result_package = None
      
      for path_token in package_path_tokens:
      
         while(packages != None):
            for package in packages:
               if package["name"] == path_token:
                  result_package = package
                  if "packages" in package.keys():
                     packages = package["packages"]
                  else:
                     packages = None
                  break
            break
               
         if result_package == None:
            raise RuntimeError('Unable to resolve package path \'' + "::".join(package_path_tokens))
                  
      return result_package
         
   def findFunction(self, func_name):
      
      func_name_tokens = func_name.split("::")
      
      if len(func_name_tokens) < 2:
         raise RuntimeError('Strange function name \'' + func_name + '\'')
         
      package = self.getPackage(func_name_tokens[:-1])

      func_name = func_name_tokens[-1]
      
      if not "functions" in package.keys():
         raise RuntimeError('No functions defined in package ' + "::".join(func_name_tokens[:-1]))
      else:
         functions = package["functions"]
         the_func = None
         for func in functions:
            if func["name"] == func_name:
               the_func = func
               break
            
         if the_func == None:
            raise RuntimeError('Unable to find function \'' + func_name + '\' in package \'' + "".join(func_name_tokens[:-1], "::"))
         else:
            return the_func
         
   def findInput(self, input_name):
      
      input_name_tokens = input_name.split("::")
      
      if len(input_name_tokens) < 2:
         raise RuntimeError('Strange input name \'' + input_name + '\'')
         
      package = self.getPackage(input_name_tokens[:-1])

      input_name = input_name_tokens[-1]
      
      if not "inputs" in package.keys():
         raise RuntimeError('No inputs defined in package' + "::".join(input_name_tokens[:-1]))
      else:
         inputs = package["inputs"]
         the_input = None
         for an_input in inputs:
            if an_input["name"] == input_name:
               the_input = an_input
               break
            
         if the_input == None:
            raise RuntimeError('Unable to find input \'' + input_name + '\' in package \'' + "".join(func_name_tokens[:-1], "::"))
         else:
            return the_input
      
   def pokeValue(self, address, size_bytes, value_str):
      
      import ctypes
      
      if size_bytes == 1:
         transfer_value = ctypes.c_uint8(int(value_str))
      elif size_bytes == 2:
         transfer_value = ctypes.c_uint16(int(value_str))
      else:
         raise RuntimeError('Function argument size ' + str(size_bytes) + \
            ' currently unsupported')
      
      cmd = [self.focus_test_executable, "remote.poke", str(address), \
                                         str(size_bytes), str(transfer_value)]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
      return transfer_value
   
   def peekValue(self, address, size_bytes):
      
      import ctypes
      
      cmd = [self.focus_test_executable, "remote.peek", str(address), \
                                         str(size_bytes)]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
      return o.decode('utf8').rstrip()
   
   def assertValueRange(self, type, value, lower, upper):
      if (value < lower) or (value > upper):
         raise RuntimeError('Value ' + str(value) + ' exceeds data range [' \
            + str(lower) + ';' + str(upper) + '] of type ' + type)
      
   def verifyValue(self, name, type, value_str):
      
      import ctypes
      
      if type == "uint8_t":
         self.assertValueRange(type, int(value_str), 0, 255)
         ctypes.c_uint8(int(value_str))
      elif type == "uint16_t":
         self.assertValueRange(type, int(value_str), 0, 65535)
         ctypes.c_uint16(int(value_str))
      elif type == "uint32_t":
         self.assertValueRange(type, int(value_str), 0, 4294967295)
         ctypes.c_uint32(int(value_str))
      elif type == "int8_t":
         self.assertValueRange(type, int(value_str), -128, 127)
         ctypes.c_int8(int(value_str))
      elif type == "int16_t":
         self.assertValueRange(type, int(value_str), -32768, 32767)
         ctypes.c_int16(int(value_str))
      elif type == "int32_t":
         self.assertValueRange(type, int(value_str), -2147483648, 2147483647)
         ctypes.c_int32(int(value_str))
      elif type == "float":
         self.assertValueRange(type, float(value_str), 1.2E-38, 3.4E+38)
         ctypes.c_float(float(value_str))
         
   def assignValue(self, arg_dict, value_str):
      
      self.verifyValue(arg_dict["name"], arg_dict["data"]["type"], value_str)
      
      print('   {0} = {1} [address = {2}, type = {3}, size = {4}]'.format(\
         arg_dict["name"], \
         value_str, \
         str(arg_dict["data"]["address"]), \
         str(arg_dict["data"]["type"]), \
         str(arg_dict["data"]["size"])))
      
      transfer_value = self.pokeValue(arg_dict["data"]["address"], arg_dict["data"]["size"], value_str)
      
   def retreiveValue(self, datum_dict):
      value_str = self.peekValue(datum_dict["data"]["address"], datum_dict["data"]["size"])
      
      self.verifyValue(datum_dict["name"], datum_dict["data"]["type"], value_str)
      
      return value_str
   
   def assignFuncArgs(self, func_name, args, args_pairs):
      
      arg_names_accepted = set()
      args_accepted = {}
      for arg in args:
         arg_names_accepted.add(arg['name'])
         args_accepted[arg['name']] = arg
         
      arg_names_supplied = set()
      
      args_supplied = {}
      
      for args_pair in args_pairs:
         
         tokens = args_pair.split("=")
         
         if len(tokens) != 2:
            raise RuntimeError('Strange function args pair \'' + args_pair + '\'')
         else:
            arg_names_supplied.add(tokens[0])
            args_supplied[tokens[0]] = tokens[1]
            
      common_arg_names = arg_names_accepted.intersection(arg_names_supplied)
      
      if len(common_arg_names) != len(arg_names_accepted):
         
         arg_names_unsupplied = arg_names_accepted.difference(arg_names_supplied)
         
         raise RuntimeError('The following arguments of function ' + func_name + \
            ' are unsupplied: ' + str(arg_names_unsupplied))
            
      superfluous_arg_names = arg_names_supplied.difference(arg_names_accepted)
      
      if len(superfluous_arg_names) != 0:
         
         raise RuntimeError('The following unaccepted arguments have been supplied '
            + 'to a call of function ' + func_name + ': ' + str(superfluous_arg_names))
      
      #print("Args accepted: " + str(arg_names_accepted))
      #print("Args supplied: " + str(arg_names_supplied))
      
      if len(args_supplied) > 0:
         print("arguments:")
         for (name, value) in args_supplied.items():
            self.assignValue(args_accepted[name], value)
         
   def readFuncResults(self, func_name, results):
      print("results:")
      if results and (len(results) > 0):
         for result in results:
            value = self.retreiveValue(result)
            print("   " + result["name"] + ": " + str(value))
      else:
         print("   [void]\n") 
         
   def invokeCallable(self, address):
            
      cmd = [self.focus_test_executable, "remote.call", str(address)]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
   def writeDescription(self, datum, target):
      if ("description" in datum.keys()) and (datum["description"] != None):
         target.write(" (" + datum["description"] + ")")
         
   def callFunction(self, name, args_pairs):
      func = self.findFunction(name)
      
      self.assignFuncArgs(name, func['arguments'], args_pairs)
      
      self.invokeCallable(func['callable']['address'])
      
      self.readFuncResults(name, func['results'])
      
   def setInput(self, input_name, value_str):
      
      the_input = self.findInput(input_name)
      
      self.assignValue(the_input, value_str)
      self.invokeCallable(the_input['callable']['address'])
      
   def getInput(self, input_name):
         
      the_input = self.findInput(input_name)
      value = self.retreiveValue(the_input)
      
      print("Value of input \'" + input_name + "\': " + value)
      
   def listIOData(self, data_list, target, indent):
      if data_list and (len(data_list) > 0):
         for datum in data_list:
            target.write(indent + datum["name"] + " [" + datum["data"]["type"] + "]")
            self.writeDescription(datum, target) 
            target.write("\n")
      else:
         target.write(indent + "[void]\n")
         
   def listInputs(self, inputs, target, indent):
      
      if len(inputs) > 0:
         target.write(indent + "inputs:\n")
         for input in inputs:
            target.write(indent + indent_level + input["name"] + " [" + input["data"]["type"] + "]\n")
         
   def listFunctions(self, functions, target, indent):
            
      if len(functions) > 0:
         target.write(indent + "functions:\n")
         for function in functions:
            target.write(indent + indent_level + function["name"])
            self.writeDescription(function, target) 
            target.write("\n")
            
            args = function["arguments"]
            target.write(indent + 2*indent_level + "arguments:\n")
            self.listIOData(args, target, indent + 3*indent_level)
            
            results = function["results"]
            target.write(indent + 2*indent_level + "results:\n")
            self.listIOData(results, target, indent + 3*indent_level)
            
            target.write("\n")
            
   def listPackage(self, package, target, indent):
      
      target.write(indent + package["name"])
      self.writeDescription(package, target)
      target.write("\n")
      
      if "inputs" in package.keys():
         self.listInputs(package["inputs"], target, indent + indent_level)
      if "functions" in package.keys():
         self.listFunctions(package["functions"], target, indent + indent_level)
      
      if "packages" in package.keys():
         for sub_package in package["packages"]:
            self.listPackage(sub_package, target, indent + indent_level)
         
   def listPackages(self, target):
      
      target.write("packages:\n")
      for package in self.getPackages():
         self.listPackage(package, target, indent_level)
      
   def processCommand(self):
      
      if len(self.remaining_args) == 0:
         raise RuntimeError('No commands provided')
         
      # Make sure the firmware that is running on the device is the same
      # that was used to generate the package information.
      #
      # TODO: This is currently not supported as there is no build step
      #       available that would allow us to save the checksum in 
      #       the firmware.
      #
      #self.validateChecksum()
      
      command_name = self.remaining_args[0]
      
      if command_name in self.commands.keys():
         self.commands[command_name].run(self.remaining_args[1:])
      else:
         raise RuntimeError('Unknown command \'' + command_name + '\' encountered')
            
   def validateChecksum(self):
      
      checksum_tokens_expected = self.package_tree['checksum'].split(' ')
      checksum_bytes_expected = map(int, checksum_tokens_expected)
      
      cmd = [self.focus_test_executable, "call", str(address)]
      proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

      o, e = proc.communicate()
      
      checksum_tokens_recieved = o.decode('utf8').rstrip().split(" ")
      checksum_bytes_received = map(int, checksum_tokens_recieved)
         
if __name__ == "__main__":
   sys.stdout.write("\n" + program_description + "\n\n")
   Communicator()
